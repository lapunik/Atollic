/*
 * nucleo_i2c.c
 *
 *  Created on: 11. 1. 2017
 *      Author: weiss_000
 */

#include "nucleo_i2c.h"

static I2C_TypeDef *_i2cNum = NULL;

bool InitI2C1(void)
{
  return InitI2C(I2C1);
}

bool InitI2C(I2C_TypeDef *portPtr)
{
  if (portPtr == NULL)
    return false;

  switch((uint32_t)portPtr)
  {
    case (uint32_t)I2C1:
      Nucleo_SetPinGPIO(GPIOB, 8, alter);
      Nucleo_SetPinGPIO(GPIOB, 9, alter_open); // !!! OPEN DRAIN

      Nucleo_SetPinAFGPIO(GPIOB, 8, 4);
      Nucleo_SetPinAFGPIO(GPIOB, 9, 4);

      if (!(RCC->APB1ENR & RCC_APB1ENR_I2C1EN))
      {
        RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
        RCC->APB1RSTR |= RCC_APB1RSTR_I2C1RST;
        RCC->APB1RSTR &= ~RCC_APB1RSTR_I2C1RST;
      }
      break;
    default:
      return false;
  }

  _i2cNum = portPtr;

  {
    uint16_t tout;

    _i2cNum->CR1 |= I2C_CR1_SWRST;   // reset peripheral signal
    for (tout = 100; tout; tout--)   // short delay
      asm("NOP");
    _i2cNum->CR1 = 0;
  }

  // clock APB1 teoreticky 25MHz, protoze Sys = AHB = 100MHz a pak /4

  // configuration
  _i2cNum->CR1 = I2C_CR1_PE;         // enable peripheral, remainnig bits = 0
  // I2C1->CR2 = 0;                  // clear all cfg. bits
  // I2C1->CR2 &= ~ I2C_CR2_FREQ;    // clear bits FREQ[5:0] - The FREQ field is used by the peripheral to generate data setup and hold times compliant with the I2C specifications.
  //  I2C1->CR2 |= I2C_CR2_FREQ_2;    // 4MHz
  //  I2C1->CR2 |= I2C_CR2_FREQ_1;    // 2MHz
  {
    int apb1div = (RCC->CFGR & RCC_CFGR_PPRE1) >> 10;  // u F411 je to bit 10..12
    int apb1clk = 0;
    int apb1mhz = 0;
    int speed = 100000;

    if ((apb1div & 0x04) == 0) // highest bit from 3 == 0 ?
      apb1clk = SystemCoreClock;  // x1, AHB = sysclock
    else
      apb1clk = SystemCoreClock >> ((apb1div & 0x03) + 1);

    apb1mhz = apb1clk / 1000000;          // clock in MHz

    _i2cNum->CR2 = apb1mhz;

    _i2cNum->CR1 = 0;                  // disable preipheral

#if 0
  // setting generated by wizard (CubeMX)
  // clock control - must be configured when PE = 0
  I2C1->CCR = 0;                  // F/S = 0 (slow), duty = 0 (pomer 2)
  I2C1->CCR |= 28;                // (11 bitu) urcuje dobu trvani high i low urovne, vychazi z FREQ a APB1, min. 4
  I2C1->TRISE = 33;               // teoreticky FREQ + 1 ???

  I2C1->CR1 |= I2C_CR1_ACK;       // enable ACK

  #define I2C_ADDRESSINGMODE_7BIT         ((uint32_t)0x00004000)
  I2C1->OAR1 = I2C_ADDRESSINGMODE_7BIT;   // dle Cube
#endif

    // inspired by Cube generated code
    _i2cNum->TRISE = (speed <= 100000U) ? (apb1mhz + 1U) : (((apb1mhz * 300U) / 1000U) + 1U);

#define I2C_SPEED_STANDARD(__PCLK__, __SPEED__)            (((((__PCLK__)/((__SPEED__) << 1U)) & I2C_CCR_CCR) < 4U)? 4U:((__PCLK__) / ((__SPEED__) << 1U)))
#define I2C_SPEED_FAST(__PCLK__, __SPEED__, __DUTYCYCLE__) (((__DUTYCYCLE__) == I2C_DUTYCYCLE_2)? ((__PCLK__) / ((__SPEED__) * 3U)) : (((__PCLK__) / ((__SPEED__) * 25U)) | I2C_DUTYCYCLE_16_9))
#define I2C_SPEED(__PCLK__, __SPEED__, __DUTYCYCLE__)      (((__SPEED__) <= 100000U)? (I2C_SPEED_STANDARD((__PCLK__), (__SPEED__))) : \
                                                                  ((I2C_SPEED_FAST((__PCLK__), (__SPEED__), (__DUTYCYCLE__)) & I2C_CCR_CCR) == 0U)? 1U : \
                                                                  ((I2C_SPEED_FAST((__PCLK__), (__SPEED__), (__DUTYCYCLE__))) | I2C_CCR_FS))
#define I2C_DUTYCYCLE_2                 ((uint32_t)0x00000000U)
#define I2C_DUTYCYCLE_16_9              I2C_CCR_DUTY

    _i2cNum->CCR = I2C_SPEED(apb1clk, speed, I2C_DUTYCYCLE_2);

    _i2cNum->CR1 |= I2C_CR1_ACK;       // enable ACK
  }

  #define I2C_DUALADDRESS_DISABLE         ((uint32_t)0x00000000)
  #define I2C_DUALADDRESS_DISABLED                I2C_DUALADDRESS_DISABLE
  _i2cNum->OAR2 = I2C_DUALADDRESS_DISABLED;  // dle Cube
  // end Wizard settings

  _i2cNum->CR1 |= I2C_CR1_PE;        // enable peripheral

  return true;
}

// read 16-bit status
static __inline uint16_t I2C_sr(void)
{
  uint16_t sr;

  sr  = _i2cNum->SR1;
  sr |= _i2cNum->SR2 << 16;
  return (sr);
}

static const uint _timeoutI2C = 10000;

// Perform I2C Start-Condition (RM 26.3.1. fig. 268)
static bool I2C_Start(void)
{
  uint w = _timeoutI2C;

  _i2cNum->CR1 |= I2C_CR1_START;
  while (!(I2C_sr() & I2C_SR1_SB))      // wait for start condition generated
  {
    if (w)
      w--;
    else
      break;
  }

  return w;
}

// Perform I2C Start-Condition (RM 26.3.1. fig. 268)
static bool I2C_Stop(void)
{
  uint w = _timeoutI2C;

  _i2cNum->CR1 |= I2C_CR1_STOP;
  while (I2C_sr() & (I2C_SR2_MSL << 16))         // Wait until BUSY bit reset
  {
    if (w)
      w--;
    else
      break;
  }

  return w;
}

// send Address
static bool I2C_Addr(uint8_t adr)
{
  uint w = _timeoutI2C;

  _i2cNum->DR = adr;
  while(!(I2C_sr() & I2C_SR1_ADDR))  // wait for sending completion
  {
    if (w)
      w--;
    else
      break;
  }

  return true;
}

// send data
static bool I2C_Write(uint8_t c)
{
  uint w = _timeoutI2C;

  _i2cNum->DR = c;
  while (!(I2C_sr() & I2C_SR1_BTF))
  {
    if (w)
      w--;
    else
      break;
  }

  return true;
}

// read data - ACK = 1
static uint8_t I2C_Read(int ack)
{
  uint w = _timeoutI2C;

  // Enable/disable Master acknowledge
  if (ack) _i2cNum->CR1 |= I2C_CR1_ACK;
  else     _i2cNum->CR1 &= ~I2C_CR1_ACK;

  while (!(I2C_sr() & I2C_SR1_RXNE))
  {
    if (w)
      w--;
    else
      break;
  }

  return (_i2cNum->DR);
}

/*
 * device: address of chip, upper 7 bits valid !!
 * adr:    register address
 * value:  value to write to register
 */
void I2C_Write8(uint8_t device, uint8_t adr, uint8_t value)
{
  I2C_Start();
  I2C_Addr(device & 0xFE);           // write - D0 = 0
  I2C_Write(adr);
  I2C_Write(value);
  I2C_Stop();
}

/*
 * device: address of chip, upper 7 bits valid !!
 * adr:    register address
 * return: value from register
 */
uint8_t I2C_Read8(uint8_t device, uint8_t adr)
{
  uint8_t b = 0;

  I2C_Start();
  I2C_Addr(device & 0xFE);          // write - D0 = 0
  I2C_Write(adr);
  I2C_Start();
  I2C_Addr(device | 0x01);          // read  - D0 = 1
  b = I2C_Read(0);                  // pro posledni jde 0
  I2C_Stop();

  return b;
}

/*
 * device: address of chip, upper 7 bits valid !!
 * adr:    register address
 * return: value from register
 */
uint16_t I2C_Read16(uint8_t device, uint8_t adr)
{
  uint16_t w = 0;

  I2C_Start();
  I2C_Addr(device & 0xFE);          // write - D0 = 0
  I2C_Write(adr);
  I2C_Start();
  I2C_Addr(device | 0x01);          // read  - D0 = 1
  w |= I2C_Read(1);                 // pro ne-posledni jde 1
  w |= 256 * I2C_Read(0);           // pro posledni jde 0
  I2C_Stop();
  return w;
}

/*
 * device: address of chip, upper 7 bits valid !!
 * adr:    register start address
 * bp:     pointer to data buffer
 * len:    requested count
 * return: count of readed bytes (eq. len)
 */
int I2C_ReadBlock(uint8_t device, uint8_t adr, uint8_t *bp, int len)
{
  int i;
  uint8_t b;

  I2C_Start();
  I2C_Addr(device & 0xFE);          // write - D0 = 0
  I2C_Write(adr);
  I2C_Start();
  I2C_Addr(device | 0x01);          // read  - D0 = 1
  for(i = 0; i < len; i++)
  {
    if (i == (len - 1))
      b = I2C_Read(0);                  // pro posledni jde 0
    else
      b = I2C_Read(1);

    bp[i] = b;
  }
  I2C_Stop();

  return i;
}
